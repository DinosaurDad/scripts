#!/usr/bin/perl -W -T
#
# Copyright (C) 2009 Rog√©rio Brito <rbrito@users.sf.net>
#
# Time-stamp: <2009-03-02 21:17:13 rbrito>
#
# This program is Free Software and is distributed under the terms of
# the GNU General Public License version 2 or, at your option, any
# latter version.
#

use strict 'vars';
use warnings;
#use diagnostics -verbose;
use utf8;

use Encode qw(encode decode);
use File::Find;
#use MP3::Info;

use MP3::Tag;


=head1 NAME

m3s - generate ContentsDB.xml file for an MP3 CD to be recognized by iTunes

=head1 SYNOPSIS

  m3s [root-dir] [dvd-title]

=head1 DESCRIPTION

The m3s program is meant to generate a ContentsDB.xml file for a
directory tree containing MP3 files meant to be burned to a CD or DVD
that can, latter, be recognized by iTunes as a "big" CD, without the
need to connect to the network to fetch metadata (this is usually the
default action that iTunes takes when an Audio CD is inserted on the
optical reader of the computer).

The C<root-dir> parameter specifies the root directory of the tree where
the MP3 files are located. They are, then, parsed and an

# Fields generated by iTunes v8:
#
#   Name (string)
#   Artist (string)
#   Album (string)
#   Genre (string)
#   Persistent ID (string, hex number, 16 digits) *
#   Play Count (int) *
#   Play Date (int, -991494962) *
#   Disc Number (int) *
#   Disc Count (int) *
#   Track Number (int)
#   Track Count (int)
#   Year (int)
#   Total Time (int)
#   Bit Rate (int)
#   Has Variable Bit Rate (boolean) *
#   Sample Rate (int)
#   Date (string, hex number, 8 digits)
#   Date Modified (date, ISO format)
#   Size (int)
#   Supports ID3 Tags (boolean)
#   Numeric Path (string)
#   File Extension (string)
#
# In the header of the contentsdb.xml file:
#   Disc ID (string, hex number, 16 digits)
#   Disc Name (string)
#
# (Fields marked with * are not present in iTunes v4.6)
#

=head1 LICENCE

This program is Free Software and is distributed under the terms of the
GNU General Public License version 2 or, at your option, any latter
version.

=head1 AUTHOR

This program was written by Rogerio Brito <rbrito@users.sf.net> on 2009-03-02.

=cut

# ==============================================================================

# Auxiliary functions for generation of the output
sub pr_header {
print <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Current Version</key><integer>1</integer>
	<key>Compatible Version</key><integer>1</integer>
	<key>Application</key><string>m3s v0.0</string>
	<key>Burner Info</key><string>$_[0]</string>
	<key>Disc ID</key><string>$_[1]</string>
	<key>Disc Name</key><string>$_[2]</string>
	<key>tracks</key>
	<array>
EOF
}
sub pr_footer { print "\t</array>\n</dict>\n</plist>\n"; }

# ==============================================================================

# Functions to generate the proper XML tags for iTunes.
sub pr_open_dict  { print "\t\t<dict>\n"; }
sub pr_key        { print "\t\t\t<key>", encode("utf8", $_[0]), "</key>"; }
sub pr_string     { print "<string>", encode("utf8", $_[0]), "</string>\n"; }
sub pr_integer    { print "<integer>", encode("utf8", $_[0]), "</integer>\n"; }
sub pr_date       { print "<date>", encode("utf8", $_[0]), "</date>\n"; }
sub pr_boolean    { if ($_[0]) { print "<true/>\n"; } else { print "<false/>\n"; }; }
sub pr_close_dict { print "\t\t</dict>\n"; }

# ==============================================================================

# Auxiliary functions
sub gen_serial_no {
    return sprintf("%04X%04X%04X%04X", rand(0xffff), rand(0xffff),
		   rand(0xffff), rand(0xffff));
}


#
#
#
sub generate_song_entry_old {
    my $mp3 = new MP3::Info $_[0];
    my %dict = ();

    # FIXME: include "Disc Number" (integer) & "Disc Count" (integer)
    if (defined($mp3->{TITLE}))  { $dict{"Name"}   = ["string", $mp3->{TITLE}]; }
    if (defined($mp3->{ARTIST})) { $dict{"Artist"} = ["string", $mp3->{ARTIST}]; }
    if (defined($mp3->{ALBUM}))  { $dict{"Album"}  = ["string", $mp3->{ALBUM}]; }
    if (defined($mp3->{GENRE}))  { $dict{"Genre"}  = ["string", $mp3->{GENRE}]; }
    if (defined($mp3->{YEAR}))   { $dict{"Year"}   = ["integer", $mp3->{YEAR}]; }
    if (defined($mp3->{SECS}))   { $dict{"Total Time"} = ["integer", int($mp3->{SECS})]; }
    if (defined($mp3->{BITRATE})){ $dict{"Bit Rate"}   = ["integer", $mp3->{BITRATE}]; }
    if (defined($mp3->{VBR}))    { $dict{"Has Variable Bit Rate"} = ["boolean", $mp3->{VBR}]; }
    if (defined($mp3->{FREQUENCY})) { $dict{"Sample Rate"} = ["integer", $mp3->{FREQUENCY}*1000]; }

    { $dict{"Date"} = ["string", 12345678]; }
    { $dict{"Date Modified"} = ["date", "2009-03-02T19:50:00Z"]; }

    if (defined($mp3->{OFFSET}) && defined($mp3->{SIZE})){
	$dict{"Size"} = ["integer", $mp3->{OFFSET}+$mp3->{SIZE}];
    }

    { $dict{"Supports ID3 Tags"} = ["boolean", 1]; }
    { $dict{"Numeric Path"} = ["string", "1:1:1"]; }
    { $dict{"File Extension"} = ["string", "mp3"]; }

    $mp3->{TRACKNUM} =~ m!(\d+)/?(\d+)?!;
    if (defined($1)) { $dict{"Track Number"} = ["integer", int($1)]; }
    if (defined($2)) { $dict{"Track Count"}  = ["integer", int($2)]; }

    pr_open_dict();

    foreach my $key (sort keys %dict) {
	if ($dict{$key}->[1]) {
	    pr_key("$key");
	    "pr_$dict{$key}->[0]"->(encode("utf8", $dict{$key}->[1]));
	}
    }

    pr_close_dict();
}


# ==============================================================================

# Function to grab information from an MP3 file
sub generate_song_entry {
    my $mp3 = new MP3::Tag $_[0];

    # Perform the information gathering from the file:
    my ($title, $track, $artist, $album, $comment, $year, $genre) = $mp3->autoinfo();

    my ($track1, $track2, $disc1, $disc2) = ($mp3->track1(), $mp3->track2(),
					     $mp3->disk1(), $mp3->disk2());

    my ($secs, $bitrate, $frequency, $is_vbr, $size) = (int($mp3->total_secs()),
							$mp3->bitrate_kbps(),
							$mp3->frequency_Hz(),
							$mp3->is_vbr(),
							$mp3->size_bytes());
    # Now, we fill in the entry for this file
    pr_open_dict();

    if (defined($title))	{ pr_key("Name"); pr_string($title); }
    if (defined($artist))	{ pr_key("Artist"); pr_string($artist); }
    if (defined($album))	{ pr_key("Album"); pr_string($album); }
    if (defined($genre))	{ pr_key("Genre"); pr_string($genre); }
    if (defined($year))		{ pr_key("Year"); pr_integer($year); }
    if (defined($track1))	{ pr_key("Track Number"); pr_integer($track1); }
    if (defined($track2))	{ pr_key("Track Count"); pr_integer($track2); }
    if (defined($disc1))	{ pr_key("Disc Number"); pr_integer($disc1); }
    if (defined($disc2))	{ pr_key("Disc Count"); pr_integer($disc2); }
    if (defined($secs))		{ pr_key("Total Time"); pr_integer($secs); }
    if (defined($bitrate))	{ pr_key("Bit Rate"); pr_integer($bitrate); }
    if (defined($frequency))	{ pr_key("Sample Rate"); pr_integer($frequency); }
    if (defined($is_vbr))	{ pr_key("Has Variable Bit Rate"); pr_boolean($is_vbr); }
    if (defined($size))		{ pr_key("Size"); pr_integer($size); };

    if ((exists($mp3->{ID3v1}) or exists($mp3->{ID3v2}))) {
	pr_key("Supports ID3 Tags"); pr_boolean(1);
    }

    # Compulsory filling
    { pr_key("Date"); pr_string(12345678); };
    { pr_key("Date Modified"); pr_date("2009-03-02T19:50:00Z"); };
    { pr_key("Numeric Path"); pr_string("1:1:1"); };
    { pr_key("File Extension"); pr_string("mp3"); };

    pr_close_dict();
}



# ==============================================================================
# main program
# ==============================================================================
{
    my $burner = $_[0]?$_[0]:"DVD-ROM DRIVE";
    my $serial = gen_serial_no();
    my $title  = $_[1]?$_[1]:"My MP3 CD-ROM";

    pr_header($burner, $serial, $title);
    generate_song_entry("test.mp3");
    pr_footer();
}
